# todos_vuejs

> todos project

## 构建配置

``` bash
# 安装依赖
npm install

# 在localhost:8088服务上运行，端口号可通过'config/index.js'文件中的port属性进行设置
npm run dev

# 快速构建产品
npm run build

```


## step1：添加任务和显示任务
### 目标
1. HTML页面结构--- div、h2、input、ul
2. 为input元素添加新增任务的方法
3. 在ul元素中显示任务列表的内容

### 实施内容
1. 在input元素上用v-model双向绑定newTodo,通过@keyup.enter监听addTodo方法
2. 在ul元素上用v-for遍历todos,预定义添加到todos里的todo是一个对象，方便以后扩展

### 实施要点
1. 新增任务方法要进行非空串、非空格和任务重复的判断


## step2：任务列表内容持久化存储和读取
### 目标
1. 对任务列表内容进行浏览器持久化本地存储和读取
2. 任务列表内容变化时及时保存数据

### 实施内容
1. 抽象出webStorage类，接收一个存储标识名参数，对外暴露webStorage实例，它提供存储和读取浏览器数据的方法
2. 添加watch选项，监听todos数据的变化，再及时保存数据到浏览器中

### 实施要点
1. 浏览器数据是以JSON格式进行存储和读取，其次当要读取的数据不存在时，将其赋值为空数组[]


## step3：任务状态和样式的切换
### 目标
1. 为每个任务添加任务完成和未完成状态的切换事件
2. 不同任务状态下有不同的样式显示
3. 点击任务内容也可实现任务状态的切换

### 实施内容
1. 为todo添加一个completed属性，记录任务状态，默认值为false
2. 在任务列表中为每个任务前添加一个复选框，用于切换任务状态，再把值v-model到todo.completed
3. 通过判断todo.completed的真假，用v-bind:class来切换不同的样式
4. 通过label的for属性，可以绑定到id相同的表单元素，这就要求动态赋值，就用到了v-bind指令和v-for的额外参数index

### 实施要点
1. 默认的watch选项，只能检测到数值、引用和数量等变化，而不能检测到引用的内部变化（todo对象中completed属性改变），因此需要添加额外的配置 
```
	watch: {
		todos: {
			handler: function (todos){
				 WebStorage("todos-vuejs").save(todos)
			},
			deep: true;
		}
	}
```
详细介绍可以查看官方文档 [#watch](http://cn.vuejs.org/v2/api/#watch)

**tips: vue不能检测到对象属性的添加或删除，因此属性必须在data对象上存在，它才能响应式变化。**

按照之前的例子，就是之前已存在的todo中没有completed属性，所以这个todo就不能响应式变化，也就是不能切换任务状态，而新增加的todo，在添加到todos前就存在了completed属性，它能正常的响应式变化，具体内容参考:[响应式原理](http://cn.vuejs.org/v2/guide/reactivity.html)


## step4：动态显示按钮及删除任务
### 目标
1. 动态显示任务删除按钮
2. 为按钮添加任务删除事件

### 实施内容
1. 添加一个按钮，默认不显示，再通过CSS的伪类选择器:hover来切换隐藏和显示（vue的@mouseenter+@mouseleave同样可以实现类似为类:hover效果）
2. 添加removeTodo(todo)方法，它接收todo对象，然后通过indexOf找到在任务数组中的位置，再通过splice方法移除该项，数据会响应式存储(watch)

### 实施要点
1. 从任务列表中移除任务，要先找到任务的位置，需要注意的是，indexOf判断的是对象的引用，因为都是来自同一个数组，所以才能找到位置


## step5：全选和全不选任务状态
### 目标
1. 点击全选复选框，实现全选和全不选任务状态的效果
2. 当全部任务状态为完成时，全选复选框自动选中，反之不选中。

### 实施内容
1. 添加一个复选框，其值v-model绑定到allDone,且allDone是一个计算属性，其get方法返回判断未完成任务的数量是否为0，为0则返回真，全选按钮被选中，反之不选中，其set方法对任务列表中所有任务进行全部完成或未完成的状态切换。
2. 当任务数量等于0，那么全选框用v-show隐藏起来

### 实施要点
1. 计算属性是依赖性变化，当方法内的数据变化时就会调用计算属性的get方法。
2. 获取未完成任务数量可使用filter对todos进行未完成任务的过滤
3. 设置全选或全不选可使用forEach对todos进行状态修改的操作


## step6：过滤显示全部、已完成、未完成任务
### 目标
1. 添加过滤选项的html结构
2. 添加全部、已完成、未完成任务列表的点击事件，显示过滤后的任务列表。

### 实施内容
1. 过滤选项结构 ----  div、ul、li
2. 当任务数量等于0，则用v-show隐藏过滤选项
3. 添加实例属性visibility，用于保存过滤选项选中的值。
4. 通过@click在每个过滤选项上绑定一个赋值给visibility的JS表达式
5. 创建新的对象filters，它封装了三个方法all、active、completed，分别返回全部任务列表、未完成任务列表和已完成任务列表。最后选择什么列表依赖于visibility的值
6. 添加计算属性filteredTodos，把显示任务列表的循环替换成显示过滤任务列表的循环，其值为`filters[this.visibility](this.todos)`

### 实施要点
1. visibility(点击)-->filteredTodos(计算)-->filters(调用)-->filteredTodos(返回值)
2. vue渲染元素默认采用“就地复用”的方式，来达到性能提升的效果，但它有时会因此带来莫名其妙的问题，为了避免复用元素，可以在v-for元素上绑定:key=XX来标识身份，避免就地复用。
比如说，点击未完成任务过滤选项，显示出三个任务内容，点击第二个任务完成，会出现复选框选中的值保留到第三个任务上，可实际上第三任务依旧是未完成的情况


## step6(1)：通过路由过滤显示任务列表
### 目标
1. 将App.vue内容分离出todos组件，再通过路由调用。
2. 点击不同的过滤选项后，再通过路由返回不同的过滤任务列表

### 实施内容
1. 在main.js中引入vue-router、自定义路由配置文件，然后全局应用路由功能Vue.use(VueRouter)和使用路由配置文件，再把路由实例添加到vue实例上，同时vue上的template中要有路由出口router-view,最后再把vue实例挂载到html元素上
2. 路由配置中路由的访问都返回todos组件，其经过路由返回的参数可以通过this.$route.params访问。由于视图切换和组件复用的原因，所以需要watch $route的变化
3. 使router-link在HTML5 hisitory 模式下，它会拦截点击事件不让浏览器重新加载页面，同时可配置tag属性生成别的标签
4. 获取到路由参数值，再过滤显示任务列表，具体处理参照step6

### 实施要点
1. 导入路由 --> 配置和应用路由 --> 路由添加到vue实例中 --> vue实例挂载到页面中
2.过滤选项(点击) --> 路由配置(匹配项) --> 组件(返回) -->  router-view视图(显示)


## step-7：显示未完成任务数量和移除已完成任务
### 目标
1. 添加移除已完成任务的按钮
2. 显示未完成任务的数量

### 实施内容
1. 当未完成任务列表数量小于总任务数量，显示移除已完成任务列表按钮。
2. 移除已完成任务列表是通过把未完成任务列表赋值给全部任务todos
3. 添加一个计算属性remaining,记录未完成任务数量

### 实施要点
1. 移除按钮只有在完成任务存在时才显示。


## step-8：编辑任务列表中的任务内容
### 目标
1. 双击任务内容，进入任务编辑状态，并获得焦点，已完成任务不能编辑内容。
2. 失去焦点时，任务内容为空，则删除该任务，否则保存修改后的任务内容。
3. 按下esc键，撤消修改，返回之前的任务内容
4. 移除点击文本复选框选中的功能，这和双击编辑任务冲突

### 实施内容
1. 为任务内容绑定双击事件执行editTodo，它会先判断任务是否未完成，若是，则将会把原始任务内容缓存到临时添加的beforeEditCache属性，同时赋值给编辑时的任务内容editedTodo，若不是，那么不执行赋值
2. 是否显示任务文本编辑框与获得焦点，需要任务编辑对象等于原始任务对象，即todo == editedTodo。
3. 任务文本编辑框获得焦点需要通过自定义的指令
4. 为任务文本编辑框绑定失去焦点事件执行doneEdit，它会将对editedTodo的title进行非空和非重复的判断，若为空，则移除该任务项，若内容重复，则撤销修改，否则退出编辑状态，并重置editedTodo对象为null
5. 为任务文本编辑框绑定键盘enter事件执行doneEdit
6. 为任务文本编辑框绑定键盘esc事件执行cancelEdit,它会重置editedTodo对象为null,再撤销任务内容的修改,即todo.title = this.beforeEditCache
7. 任务文本编辑框需要v-model绑定todo.title，确保数据发生变化时，视图也跟着变化。

### 实施要点
1. 进入任务编辑状态时，原始对象会被赋值给任务编辑对象，由于它们引用同一个对象，所以任务编辑对象修改title值，原始对象也会相应变化
2. 自定义指定，其值可以为其配置钩子对象，钩子对象上可以配置各种钩子函数，其值也可以为函数，则为简写方式，会在 bind 和 update 钩子上做重复动作。钩子函数拥有两个参数，第一个参数是指令所绑定的元素el，第二个参数是一个绑定对象binding，它包含传入的值和值的变化等


## step-9：HTML语义化、结构重排和BUG修复
### 目标
1. 通过section、header和footer标签来划分区域，section标记todos功能的容器，其包含header头部、section主体内容和footer底部。

### 实施内容
1. header头部，它包含标题(h2)、全选复选框(input)和新增任务输入框(input).
2. section主体内容，它包含任务列表的渲染(ul),每个任务项(li)由任务视图区(section)和编辑框(input)组成，任务视图区包含单项复选框(input)、任务内容(label)和删除按钮(button)
3. footer底部，它包含显示未完成任务数量区(span)、过滤选项区(ul)和移除所有已完成任务按钮(button),过滤选项区中每个li包含路由访问(router-link)

### 修复内容
1. v-for循环中li复用问题，不复用li就要求，当DOM更新时，v-bind:key的值是不同的，同时又要求切换路由后key值也是不一样的，那么key值就应该是`todo.titile+visibility`
2. 任务编辑框的内容不应该直接双向绑定到todo.title,因为这会引起DOM数据的更新，从而让任务编辑框失去焦点，只有当确认编辑框内容(enter)、失去焦点(blur)或撤销编辑(esc)时，才和todo.title关联，再引起DOM数据的变化
3. 任务编辑框获得焦点后，默认移动光标至文本末尾，支持主流浏览器。












































